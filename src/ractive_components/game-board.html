<link rel='ractive' href='./paddle.html'>
<link rel='ractive' href='./ball.html'>
<link rel='ractive' href='./brick.html'>

<svg viewBox='-10 -10 {{board.width+20}} {{board.height+20}}' on-click='launch()'>
	<rect width='{{board.width}}' height='{{board.height}}' fill='rgba(255,255,255,0.8)' stroke='rgba(0,0,0,0.4)'/>

	<text text-anchor='end' x='100%'>
		<tspan dx='-2em' dy='2em'>Score: {{game.score}}</tspan>
	</text>

	<text text-anchor='start'>
		<tspan dx='1em' dy='2em'>Lives: </tspan>
	</text>

	<g transform='translate(120,25) scale(1.5)'>
		{{#each range(1,game.lives) :i}}
			<image x='{{i*30}}' width='21.5' height='39.7' xlink:href='${version}/files/coke.png'>
		{{/each}}
	</g>

	<g class='bricks'>
		{{#each bricks :r}}
			{{#each this :c}}
				<brick type='{{this}}' column='{{c}}' row='{{r}}'/>
			{{/each}}
		{{/each}}
	</g>


	<paddle/>
	<ball x='{{ball.x}}' y='{{ball.y}}' r='{{ball.r}}' radius='{{ball.radius}}'/>


	{{#if gameOver}}
		<rect width='{{board.width}}' height='{{board.height}}' fill='rgba(255,255,255,0.8)' stroke='rgba(0,0,0,0.4)'/>
		<text x='{{board.width/2}}' y='{{board.height/2 - 50}}' class='game-over large'>Visa denied!</text>
		<text x='{{board.width/2}}' y='{{board.height/2}}' class='game-over'>Click to try again</text>
	{{/if}}
</svg>


<style>
	svg {
		width: 100%;
		height: 100%;
		/*background-color: rgba(255,255,255,0.7);*/
	}

	text {
		font-family: Abel;
		font-size: 2em;
	}

	.game-over {
		text-anchor: middle;
	}

	.large {
		font-size: 6em;
		font-weight: bold;
	}
</style>

<script>
	var rAF = require( 'utils/compatibility/requestAnimationFrame' ),
		now = require( 'utils/timing/now' ),
		deepClone = require( 'utils/core/deepClone' ),

		bounceOffWalls = require( 'helpers/bounceOffWalls' ),
		bounceOffCeiling = require( 'helpers/bounceOffCeiling' ),

		data = require( 'data' );

	component.exports = {
		data: {
			// global settings
			board: {
				width: 1000,
				height: 1000,
				brickWidth: 1000 / 16,
				brickHeight: 40
			},

			// paddle
			paddle: {
				width: 200,
				height: 30,
				x: 500,
				y: 950
			},

			// ball
			ball: {
				resting: true,
				radius: 35,
				x: 510,
				y: 900,
				r: 0,
				vx: 0,
				vy: 0,
				vr: 0
			},

			range: function ( low, high ) {
				var i, result = [];
				for ( i = low; i <= high; i += 1 ) {
					result.push( i );
				}
				return result;
			}
		},

		sounds: {
			breakFree: audio( 'break-free.mp3' ),
			boing: audio( 'boing_x.wav' ),
			hit: audio( 'sfx/hit.wav' )
		},

		oninit: function () {
			var frame, lastTime, game, board, bricks, ball, paddle;

			board = this.get( 'board' );
			game = this.get( 'game' );
			ball = this.get( 'ball' );
			paddle = this.get( 'paddle' );
			bricks = this.get( 'bricks' );

			lastTime = now();

			frame = () => {
				var time, elapsed, dx, dy;

				window.meter.tick();
				rAF( frame );

				time = now();
				elapsed = ( time - lastTime ) / 1000;

				if ( !ball.resting && game.speed && !game.paused ) {
					dx = ball.vx * elapsed * game.speed;
					dy = ball.vy * elapsed * game.speed;

					ball.x += dx;
					ball.y += dy;
					ball.r += ball.vr;

					bounceOffWalls( ball, board );
					bounceOffCeiling( ball, board );
					this.bounceOffPaddle( ball, paddle );

					this.destroyBricks( ball, bricks, dx, dy, board, game );

					if ( ball.y - ball.radius > board.height ) {
						this.loseLife();
					}

					this.update( 'ball' );
				}


				lastTime = time;
			};

			rAF( frame );
		},

		setupKeyboard: function () {
			window.addEventListener( 'keypress', event => {
				if ( event.which === 32 ) {
					this.toggle( 'game.paused' );
				}
			});
		},

		setupMouse: function () {
			var handleLockChange, mouselock, screenX;

			handleLockChange = () => {
				var lockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;

				mouselock = lockElement === this.svg;
				this.set( 'mouselock', mouselock );
			};

			document.addEventListener( 'pointerlockchange', handleLockChange, false );
			document.addEventListener( 'mozpointerlockchange', handleLockChange, false );
			document.addEventListener( 'webkitpointerlockchange', handleLockChange, false );

			document.addEventListener( 'mousemove', event => {
				if ( mouselock ) {
					screenX += event.movementX;
				} else {
					screenX = event.clientX;
				}

				if ( !this.get( 'game.paused' ) ) {
					this.movePaddle( screenX );
				}
			});
		},

		onrender: function () {
			this.svg = this.find( 'svg' );
			this.setupMouse();
			this.setupKeyboard();

			//this.sounds.breakFree.play();
		},

		movePaddle: function ( screenX ) {
			var ctm = this.svg.getScreenCTM(),
				boardX = ( screenX - ctm.e ) / ctm.a,
				paddle = this.get( 'paddle' ),
				halfWidth = paddle.width / 2,
				min = halfWidth,
				max = this.get( 'board.width' ) - halfWidth,
				newPaddleX;

			newPaddleX = Math.max( min, Math.min( max, boardX ) );

			if ( this.get( 'ball.resting' ) ) {
				this.add( 'ball.x', newPaddleX - paddle.x );
			}

			this.set( 'paddle.x', newPaddleX );
		},

		launch: function () {
			var ball, vx, vy, vr;

			if ( !this.get( 'mouselock' ) ) {
				this.svg.requestPointerLock();
			}

			ball = this.get( 'ball' );

			if ( ball.resting ) {
				ball.vx = ( ball.x - this.get( 'paddle.x' ) ) * 20;
				ball.vy = -600;
				ball.vr = ball.vx / 200;

				ball.resting = false;

				this.update( 'ball ');
			}
		},

		loseLife: function () {
			var ball = this.get( 'ball' );

			if ( !this.get( 'game.lives' ) ) {
				this.gameOver();
				return;
			}

			this.subtract( 'game.lives' );

			ball.resting = true;
			ball.vx = ball.vy = ball.vr = 0;

			ball.x = this.get( 'paddle.x' ) + ( Math.random() - 0.5 ) * 40;
			ball.y = this.get( 'paddle.y' ) - ball.radius;

			this.update( 'ball' );
		},

		gameOver: function () {
			this.set({
				gameOver: true,
				'game.paused': true
			});

			document.exitPointerLock();
		},

		bounceOffPaddle: function ( ball, paddle ) {
			var paddleLeft, paddleRight, paddleRadius;

			// trivial rejects
			if ( ball.y + ball.radius < paddle.y ) return;
			if ( ball.x + ball.radius < paddle.x - paddle.width / 2 ) return;
			if ( ball.x - ball.radius > paddle.x + paddle.width / 2 ) return;

			paddleLeft = paddle.x - paddle.width / 2;
			paddleRight = paddle.x + paddle.width / 2;
			paddleRadius = paddle.height / 2;

			// trivial accepts
			if ( ( ball.x > paddleLeft + paddleRadius ) && ( ball.x < paddleRight - paddleRadius ) ) {
				ball.y = ( paddle.y - ( ball.y + ball.radius - paddle.y ) - ball.radius );
				ball.vx += ( ball.x - paddle.x ) * 4;
			}

			// possible intersection between rounded edges
			// TODO

			ball.vy *= -1;
			this.sounds.boing.play();
		},

		destroyBricks: function ( ball, bricks, dx, dy, board, game ) {
			var rowNum,
				columnNum,
				row,
				column,
				brick,
				c1, c2, r1, r2,
				x,
				y,
				candidates,
				candidate,
				collision,
				i;

			x = ball.vx > 0 ? ball.x + ball.radius : ball.x - ball.radius;
			y = ball.vy > 0 ? ball.y + ball.radius : ball.y - ball.radius;

			c1 = ~~( x / board.brickWidth );
			c2 = ~~( ( x + dx ) / board.brickWidth );

			r1 = ~~( y / board.brickHeight );
			r2 = ~~( ( y + dy ) / board.brickHeight );

			if ( c2 !== c1 ) {
				c2 = c2 > c1 ? c1 + 1 : c1 - 1;
			}

			if ( r2 !== r1 ) {
				r2 = r2 > r1 ? r1 + 1 : r1 - 1;
			}

			row = bricks[ r2 ];
			if ( !row ) return;

			brick = row[ c2 ];
			if ( !brick ) return;

			if ( c2 !== c1 ) {
				ball.vx *= -1;
			}

			if ( r2 !== r1 ) {
				ball.vy *= -1;
			}

			this.set( 'bricks[' + r2 + '][' + c2 + ']', null );
			this.sounds.hit.play();

			if ( won( bricks ) ) {
				this.won();
			}
		},

		won: function () {
			window.alert( 'you won!' );
		}
	};

	function audio ( filename ) {
		var node, src;

		node = new Audio();
		src = '${version}/files/' + filename;

		node.addEventListener( 'ended', () => {
			node.src = src;
		});

		node.src = src;
		return node;
	}

	function won ( bricks ) {
		var r, c, row;

		r = bricks.length;
		while ( r-- ) {
			row = bricks[r];
			c = row.length;
			while ( c-- ) {
				if ( row[c] ) {
					return false;
				}
			}
		}

		return true;
	}
</script>
